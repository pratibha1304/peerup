"use client"

import { useEffect, useMemo, useState } from 'react'
import {
  Goal,
  Task,
  listenToGoals,
  listenToTasks,
  addGoal,
  addTask,
  toggleTask,
  updateGoal,
  deleteGoal,
  deleteTask,
  updateTask,
  clearGoalTasks,
} from '@/lib/goals'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle } from '@/components/ui/dialog'

type GoalsViewProps = {
  partnershipId: string
  currentUserId?: string | null
  participants?: string[]
}

export default function GoalsView({
  partnershipId,
  currentUserId,
  participants = [],
}: GoalsViewProps) {
  const [goals, setGoals] = useState<Goal[]>([])
  const [activeGoalId, setActiveGoalId] = useState<string | null>(null)
  const [tasks, setTasks] = useState<Task[]>([])
  const [isAddGoalOpen, setIsAddGoalOpen] = useState(false)
  const [newGoalTitle, setNewGoalTitle] = useState('')
  const [newGoalDescription, setNewGoalDescription] = useState('')
  const [newTaskText, setNewTaskText] = useState('')
  const [isGeneratingTasks, setIsGeneratingTasks] = useState(false)
  const [desiredTaskCount, setDesiredTaskCount] = useState(5)
  const [goalBeingEdited, setGoalBeingEdited] = useState<Goal | null>(null)
  const [isEditGoalOpen, setIsEditGoalOpen] = useState(false)
  const [goalFormTitle, setGoalFormTitle] = useState('')
  const [goalFormDescription, setGoalFormDescription] = useState('')
  const [taskEditor, setTaskEditor] = useState<{ open: boolean; task: Task | null }>({ open: false, task: null })
  const [taskForm, setTaskForm] = useState({ text: '', details: '', durationDays: '' })
  const [regenTaskCount, setRegenTaskCount] = useState(5)
  const [isRegenerating, setIsRegenerating] = useState(false)

  useEffect(() => {
    const unsub = listenToGoals(partnershipId, setGoals)
    return () => unsub()
  }, [partnershipId])

  useEffect(() => {
    if (!activeGoalId) return
    const unsub = listenToTasks(partnershipId, activeGoalId, setTasks)
    return () => unsub()
  }, [partnershipId, activeGoalId])

  const activeGoal = useMemo(() => goals.find((g) => g.id === activeGoalId) || null, [goals, activeGoalId])

  const handleCreateGoal = async (autoGenerateTasks = false) => {
    if (!newGoalTitle.trim()) return
    
    setIsGeneratingTasks(autoGenerateTasks)
    try {
      // Create the goal first
      const createdGoalId = await addGoal(partnershipId, newGoalTitle, newGoalDescription || undefined)
      setActiveGoalId(createdGoalId)
      
      // If auto-generate tasks, wait a moment for goal to be created, then generate tasks
      if (autoGenerateTasks) {
        try {
          const response = await fetch('/api/ai/breakdown-goal', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              goalTitle: newGoalTitle.trim(),
              goalDescription: newGoalDescription.trim() || undefined,
              existingGoals: goals.map(g => ({ title: g.title, description: g.description })),
              taskCount: desiredTaskCount,
            }),
          })

          if (!response.ok) {
            throw new Error(`API error: ${response.status}`)
          }

          const data = await response.json()

          if (data.tasks && Array.isArray(data.tasks) && data.tasks.length > 0) {
            for (const taskEntry of data.tasks) {
              const label =
                typeof taskEntry === 'string'
                  ? taskEntry
                  : taskEntry?.title || taskEntry?.text || ''
              if (!label.trim()) continue

              const details =
                typeof taskEntry === 'object'
                  ? (taskEntry.description || taskEntry.details || '').toString()
                  : ''
              const durationDays =
                typeof taskEntry === 'object' && Number.isFinite(taskEntry.durationDays)
                  ? Number(taskEntry.durationDays)
                  : null

              await addTask(partnershipId, createdGoalId, label.trim(), {
                details,
                durationDays,
              })
            }
          } else {
            console.warn('No tasks generated by AI')
            alert('AI did not return any tasks. Please add them manually.')
          }
        } catch (aiError) {
          console.error('Failed to generate tasks with AI:', aiError)
          alert('AI task generation failed. You can add tasks manually.')
        }
      }
      
      setNewGoalTitle('')
      setNewGoalDescription('')
      setDesiredTaskCount(5)
      setIsAddGoalOpen(false)
    } finally {
      setIsGeneratingTasks(false)
    }
  }

  const handleAddTask = async () => {
    if (!activeGoalId || !newTaskText.trim()) return
    await addTask(partnershipId, activeGoalId, newTaskText)
    setNewTaskText('')
  }

  const openGoalEditor = (goal: Goal) => {
    setGoalBeingEdited(goal)
    setGoalFormTitle(goal.title)
    setGoalFormDescription(goal.description || '')
    setIsEditGoalOpen(true)
  }

  const handleGoalUpdate = async () => {
    if (!goalBeingEdited) return
    await updateGoal(partnershipId, goalBeingEdited.id, {
      title: goalFormTitle,
      description: goalFormDescription,
    })
    setIsEditGoalOpen(false)
  }

  const handleGoalDelete = async (goalId: string) => {
    if (!window.confirm('Delete this goal and all of its tasks?')) return
    await deleteGoal(partnershipId, goalId)
    if (activeGoalId === goalId) {
      setActiveGoalId(null)
    }
  }

  const openTaskEditor = (task: Task) => {
    setTaskEditor({ open: true, task })
    setTaskForm({
      text: task.text,
      details: task.details || '',
      durationDays:
        typeof task.durationDays === 'number' ? String(task.durationDays) : '',
    })
  }

  const handleTaskUpdate = async () => {
    if (!activeGoal || !taskEditor.task) return
    const durationClean = taskForm.durationDays.trim()
    const parsedDuration =
      durationClean === '' ? null : Number.parseInt(durationClean, 10)
    await updateTask(partnershipId, activeGoal.id, taskEditor.task.id, {
      text: taskForm.text,
      details: taskForm.details,
      durationDays: Number.isNaN(parsedDuration) ? null : parsedDuration,
    })
    setTaskEditor({ open: false, task: null })
  }

  const handleTaskDelete = async (taskId: string) => {
    if (!activeGoal) return
    if (!window.confirm('Remove this task from the goal?')) return
    await deleteTask(partnershipId, activeGoal.id, taskId)
  }

  const handleRegenerateTasks = async () => {
    if (!activeGoal) return
    if (
      !window.confirm(
        'This will remove all existing tasks for this goal and replace them with new AI-generated tasks. Continue?'
      )
    )
      return
    setIsRegenerating(true)
    try {
      await clearGoalTasks(partnershipId, activeGoal.id)
      const response = await fetch('/api/ai/breakdown-goal', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          goalTitle: activeGoal.title,
          goalDescription: activeGoal.description || undefined,
          existingGoals: goals
            .filter((g) => g.id !== activeGoal.id)
            .map((g) => ({ title: g.title, description: g.description })),
          taskCount: regenTaskCount,
        }),
      })

      if (!response.ok) {
        throw new Error(`API error: ${response.status}`)
      }
      const data = await response.json()
      if (data.tasks && Array.isArray(data.tasks) && data.tasks.length > 0) {
        for (const taskEntry of data.tasks) {
          const label =
            typeof taskEntry === 'string'
              ? taskEntry
              : taskEntry?.title || taskEntry?.text || ''
          if (!label.trim()) continue
          const details =
            typeof taskEntry === 'object'
              ? (taskEntry.description || taskEntry.details || '').toString()
              : ''
          const durationDays =
            typeof taskEntry === 'object' && Number.isFinite(taskEntry.durationDays)
              ? Number(taskEntry.durationDays)
              : null
          await addTask(partnershipId, activeGoal.id, label.trim(), {
            details,
            durationDays,
          })
        }
      } else {
        alert('AI did not return any tasks. Please try again later.')
      }
    } catch (err) {
      console.error(err)
      alert('Failed to regenerate tasks. Please try again.')
    } finally {
      setIsRegenerating(false)
    }
  }

  return (
    <div className="max-w-4xl mx-auto p-6">
      <div className="flex items-center justify-between mb-6">
        <h1 className="text-2xl font-semibold">Goals</h1>
        <Button onClick={() => setIsAddGoalOpen(true)}>+ Add Goal</Button>
      </div>

      {/* Goals list */}
      <div className="grid gap-4 sm:grid-cols-2">
        {goals.map((g) => {
          const pct = g.taskCount > 0 ? Math.round((g.completedTaskCount / g.taskCount) * 100) : 0
          return (
            <button key={g.id} className="text-left rounded-xl border p-4 hover:bg-gray-50 transition-colors" onClick={() => setActiveGoalId(g.id)}>
              <div className="font-medium mb-1">{g.title}</div>
              <div className="text-xs text-muted-foreground mb-2">{g.completedTaskCount} of {g.taskCount} tasks</div>
              <div className="w-full h-2 bg-muted rounded-full overflow-hidden">
                <div className="h-full bg-primary" style={{ width: `${pct}%` }} />
              </div>
            </button>
          )
        })}
      </div>

      {/* Goal detail */}
      {activeGoal && (
        <div className="mt-8 rounded-xl border p-4">
          <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-3 mb-4">
            <div>
              <div className="text-lg font-semibold">{activeGoal.title}</div>
              {activeGoal.description && (
                <div className="text-sm text-muted-foreground">{activeGoal.description}</div>
              )}
            </div>
            <div className="flex flex-wrap gap-2">
              <Button variant="ghost" onClick={() => openGoalEditor(activeGoal)}>
                Edit goal
              </Button>
              <Button variant="destructive" onClick={() => handleGoalDelete(activeGoal.id)}>
                Delete goal
              </Button>
              <Button variant="outline" onClick={() => setActiveGoalId(null)}>
                Close
              </Button>
            </div>
          </div>

          <div className="flex flex-col gap-3 md:flex-row md:items-center md:justify-between mb-4">
            <div className="flex items-center gap-2">
              <label className="text-sm font-medium">AI tasks to generate</label>
              <Input
                type="number"
                min={1}
                max={12}
                value={regenTaskCount}
                onChange={(e) => {
                  const parsed = Number(e.target.value)
                  if (Number.isFinite(parsed)) {
                    setRegenTaskCount(Math.max(1, Math.min(12, Math.floor(parsed))))
                  } else {
                    setRegenTaskCount(1)
                  }
                }}
                className="w-24"
              />
            </div>
            <Button variant="outline" onClick={handleRegenerateTasks} disabled={isRegenerating}>
              {isRegenerating ? 'Rebuilding tasks...' : 'Replace with AI tasks'}
            </Button>
          </div>

          <div className="space-y-3 mb-4">
            {tasks.map((t) => {
              const completion = t.completedBy || {}
              const isUnlocked = t.unlocked ?? true
              const youChecked = currentUserId ? !!completion[currentUserId] : false
              const canToggle =
                !!currentUserId && (participants.length === 0 || participants.includes(currentUserId))
              const otherParticipants = participants
                .filter((uid) => uid !== currentUserId)
              const partnersDone =
                otherParticipants.length === 0 ||
                otherParticipants.every((uid) => !!completion[uid])
              const waitingOnPartner = isUnlocked && youChecked && !partnersDone && !t.isComplete

              return (
                <div
                  key={t.id}
                  className={`rounded-lg border p-3 ${!isUnlocked && !t.isComplete ? 'opacity-60' : ''}`}
                >
                  <div className="flex items-start gap-3">
                    <input
                      type="checkbox"
                      checked={youChecked}
                      disabled={!isUnlocked || !canToggle}
                      onChange={(e) =>
                        toggleTask(partnershipId, activeGoal.id, t.id, e.target.checked, participants)
                      }
                    />
                    <div className="flex-1 space-y-1">
                      <div className="flex flex-col gap-1">
                        <div className="flex items-start justify-between gap-3">
                          <span
                            className={`font-medium ${
                              t.isComplete ? 'line-through text-muted-foreground' : ''
                            }`}
                          >
                            {t.text}
                          </span>
                          {typeof t.durationDays === 'number' && (
                            <span className="text-xs px-2 py-0.5 rounded-full bg-primary/10 text-primary font-medium">
                              {t.durationDays} {t.durationDays === 1 ? 'day' : 'days'}
                            </span>
                          )}
                        </div>
                        {t.details && (
                          <p className="text-sm text-muted-foreground">{t.details}</p>
                        )}
                      </div>
                      {!isUnlocked && (
                        <p className="text-xs text-amber-600">
                          Unlocks after the previous task is completed by both of you.
                        </p>
                      )}
                      {waitingOnPartner && (
                        <p className="text-xs text-muted-foreground">
                          Waiting for your partner to mark this as done.
                        </p>
                      )}
                      {t.isComplete && (
                        <p className="text-xs text-emerald-600">Completed by both partners.</p>
                      )}
                      <div className="flex gap-3 text-xs font-medium pt-1">
                        <button
                          type="button"
                          className="text-[#2C6485] hover:underline"
                          onClick={() => openTaskEditor(t)}
                        >
                          Edit
                        </button>
                        <button
                          type="button"
                          className="text-red-600 hover:underline"
                          onClick={() => handleTaskDelete(t.id)}
                        >
                          Delete
                        </button>
                      </div>
                    </div>
                  </div>
                </div>
              )
            })}
            {tasks.length === 0 && <div className="text-sm text-muted-foreground">No tasks yet.</div>}
          </div>

          <div className="flex gap-2">
            <Input placeholder="Add a task..." value={newTaskText} onChange={(e) => setNewTaskText(e.target.value)} />
            <Button onClick={handleAddTask}>Add Task</Button>
          </div>
        </div>
      )}

      {/* Add Goal dialog */}
      <Dialog open={isAddGoalOpen} onOpenChange={setIsAddGoalOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>New Goal</DialogTitle>
            <DialogDescription>Define the objective for this partnership. AI can automatically break it down into tasks.</DialogDescription>
          </DialogHeader>
          <div className="space-y-4">
            <Input 
              placeholder="Goal title (required)" 
              value={newGoalTitle} 
              onChange={(e) => setNewGoalTitle(e.target.value)}
              onKeyDown={(e) => {
                if (e.key === 'Enter' && !e.shiftKey && newGoalTitle.trim()) {
                  handleCreateGoal(false)
                }
              }}
            />
            <textarea
              placeholder="Goal description (optional)"
              value={newGoalDescription}
              onChange={(e) => setNewGoalDescription(e.target.value)}
              className="w-full min-h-[80px] px-3 py-2 border border-gray-200 rounded-md resize-none"
            />
            <div>
              <Input
                type="number"
                min={1}
                max={12}
                value={desiredTaskCount}
                onChange={(e) => {
                  const parsed = Number(e.target.value)
                  if (Number.isFinite(parsed)) {
                    setDesiredTaskCount(Math.max(1, Math.min(12, Math.floor(parsed))))
                  } else {
                    setDesiredTaskCount(1)
                  }
                }}
                placeholder="Number of AI tasks"
              />
              <p className="text-xs text-muted-foreground mt-1">
                AI will break the goal into this many sequential tasks, each with its own day estimate.
              </p>
            </div>
            <div className="flex gap-2">
              <Button 
                onClick={() => handleCreateGoal(false)} 
                disabled={!newGoalTitle.trim() || isGeneratingTasks}
                variant="outline"
              >
                Create Goal
              </Button>
              <Button 
                onClick={() => handleCreateGoal(true)} 
                disabled={!newGoalTitle.trim() || isGeneratingTasks}
                className="bg-indigo-600 hover:bg-indigo-700"
              >
                {isGeneratingTasks ? 'Generating tasks...' : 'Create + AI Tasks'}
              </Button>
            </div>
            {isGeneratingTasks && (
              <div className="text-sm text-gray-500 flex items-center gap-2">
                <div className="w-4 h-4 border-2 border-indigo-600 border-t-transparent rounded-full animate-spin"></div>
                Using AI to generate actionable tasks...
              </div>
            )}
          </div>
        </DialogContent>
      </Dialog>

      {/* Edit Goal dialog */}
      <Dialog open={isEditGoalOpen} onOpenChange={setIsEditGoalOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Edit goal</DialogTitle>
            <DialogDescription>Adjust the title or description for your partnership goal.</DialogDescription>
          </DialogHeader>
          <div className="space-y-4">
            <Input
              placeholder="Goal title"
              value={goalFormTitle}
              onChange={(e) => setGoalFormTitle(e.target.value)}
            />
            <textarea
              placeholder="Goal description"
              value={goalFormDescription}
              onChange={(e) => setGoalFormDescription(e.target.value)}
              className="w-full min-h-[80px] px-3 py-2 border border-gray-200 rounded-md resize-none"
            />
            <div className="flex justify-end gap-2">
              <Button variant="outline" onClick={() => setIsEditGoalOpen(false)}>
                Cancel
              </Button>
              <Button onClick={handleGoalUpdate} disabled={!goalFormTitle.trim()}>
                Save changes
              </Button>
            </div>
          </div>
        </DialogContent>
      </Dialog>

      {/* Edit Task dialog */}
      <Dialog
        open={taskEditor.open}
        onOpenChange={(open) => {
          if (!open) {
            setTaskEditor({ open: false, task: null })
          } else {
            setTaskEditor((prev) => ({ ...prev, open: true }))
          }
        }}
      >
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Edit task</DialogTitle>
            <DialogDescription>Update the text, extra details, or duration estimate.</DialogDescription>
          </DialogHeader>
          <div className="space-y-4">
            <Input
              placeholder="Task title"
              value={taskForm.text}
              onChange={(e) => setTaskForm((prev) => ({ ...prev, text: e.target.value }))}
            />
            <textarea
              placeholder="Details"
              value={taskForm.details}
              onChange={(e) => setTaskForm((prev) => ({ ...prev, details: e.target.value }))}
              className="w-full min-h-[80px] px-3 py-2 border border-gray-200 rounded-md resize-none"
            />
            <Input
              type="number"
              min={1}
              max={30}
              placeholder="Duration (days)"
              value={taskForm.durationDays}
              onChange={(e) => setTaskForm((prev) => ({ ...prev, durationDays: e.target.value }))}
            />
            <div className="flex justify-end gap-2">
              <Button variant="outline" onClick={() => setTaskEditor({ open: false, task: null })}>
                Cancel
              </Button>
              <Button onClick={handleTaskUpdate} disabled={!taskForm.text.trim()}>
                Save task
              </Button>
            </div>
          </div>
        </DialogContent>
      </Dialog>
    </div>
  )
}


